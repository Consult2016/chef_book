\section{Defining environments}

An environment is a way to map an organization's real-life workflow to what can be configured and managed when using server. Every organization begins with a single environment called the <<\_default>> environment, which cannot be modified (or deleted). Additional environments can be created to reflect each organization's patterns and workflow. For example, creating production, staging, testing, and development environments. Generally, an environment is also associated with one (or more) cookbook versions.

We create for our example development environment:

\begin{lstlisting}[label=lst:my-cloud-chef-environment1,title=my-cloud/environments/development.json]
{
  "name": "development",
  "description": "development environment",
  "chef_type": "environment",
  "json_class": "Chef::Environment",
  "default_attributes": {
    "apache": {
      "timeout": 120
    }
  }
}
\end{lstlisting}

Let's consider a json structure:

\begin{itemize}
  \item \textbf{name} - a unique name of environment
  \item \textbf{description} - a description of the environment
  \item \textbf{chef\_type} - this should always be set to environment
  \item \textbf{json\_class} - this should always be set to Chef::Environment
  \item \textbf{default\_attributes} - a set of attributes that should be applied to all nodes, assuming the node does not already have a value for the attribute. This is useful for setting global defaults that can then be overridden for specific nodes. This attribute is optional
  \item \textbf{override\_attributes} - a set of attributes that should be applied to all nodes, even if the node already has a value for an attribute. This is useful for ensuring that certain attributes always have specific values. This attribute is optional
\end{itemize}

As you can see environment doesn't have run\_list, but it have attributes. Attributes in most cases contain information, which specific for environment: connection information to databases, cluster settings for database or queue, etc.

Now we can activate this development environment in Vagrantfile:

\begin{lstlisting}[label=lst:my-cloud-chef-environment2,title=my-cloud/Vagrantfile]
Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  ...
    chef.environments_path = Chef::Config[:environment_path]
    chef.environment = ENV['ENVIRONMENT'] || 'development'
  ...
end
\end{lstlisting}

and check how it works:

\begin{lstlisting}[language=Bash,label=lst:my-cloud-chef-environment3]
$ vagrant provision
...
[2013-12-31T21:53:57+00:00] INFO: Chef Run complete in 1.105324838 seconds
[2013-12-31T21:53:57+00:00] INFO: Running report handlers
[2013-12-31T21:53:57+00:00] INFO: Report handlers complete
\end{lstlisting}

To <<cook>> server by knife with environment you should use <<-E>> argument:

\begin{lstlisting}[language=Bash,label=lst:my-cloud-chef-environment4]
$ knife solo cook vagrant@localhost -i ~/.vagrant.d/insecure_private_key -p 2222 -N web1.example.com -E development
Running Chef on localhost...
Checking Chef version...
...
  * service[apache2] action start (up to date)
Chef Client finished, 1 resources updated
\end{lstlisting}

You can set environment for node by attribute <<environment>>:

\begin{lstlisting}[language=JSON,label=lst:my-cloud-chef-environment5,title=my-cloud/nodes/web1.example.com.json]
{
  "environment": "development",
  "run_list": [
    "recipe[apache2]"
  ]
}
\end{lstlisting}

and use commad <<knife solo cook>> without <<-E>> argument.

As you can see in Chef Solo environment can be used only for setting attributes. In Chef Server it have additional feature for locking cookbook versions, which we will consider in Chef Server chapter.