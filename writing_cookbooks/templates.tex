\section{Templates}

As you can see in previous chapter we used resource \inline{template} for generate nginx config in default recipe. A cookbook template is a file written in a markup language that allows the contents of a file to be dynamically generated based on variables or complex logic. Templates can contain Ruby expressions and statements. Templates are a great way to manage configuration files across an organization. A template requires a template resource being added to a recipe and then a corresponding Embedded Ruby (ERB) template being added to a cookbook.

To use a template, two things must happen:

\begin{itemize}
  \item A template resource must be added to a recipe
  \item An Embedded Ruby (ERB) template must be added to a cookbook
\end{itemize}

For example, the following template file and template resource settings can be used to manage a configuration file named \inline{/etc/sudoers}. Within a cookbook that uses sudo, the following resource could be added to \inline{recipes/default.rb}:

\begin{lstlisting}[label=lst:cookbook-templates1]
template "/etc/sudoers" do
  source "sudoers.erb"
  mode 0440
  owner "root"
  group "root"
  variables({
     :sudoers_groups => node[:authorization][:sudo][:groups],
     :sudoers_users => node[:authorization][:sudo][:users]
  })
end
\end{lstlisting}

And then create a template called \inline{sudoers.erb} and save it to \inline{templates/default/sudoers.erb}:

\begin{lstlisting}[label=lst:cookbook-templates2]
#
# /etc/sudoers
#
# Generated by Chef for <%= node[:fqdn] %>
#

Defaults        !lecture,tty_tickets,!fqdn

# User privilege specification
root          ALL=(ALL) ALL

<% @sudoers_users.each do |user| -%>
<%= user %>   ALL=(ALL) <%= "NOPASSWD:" if @passwordless %>ALL
<% end -%>

# Members of the sysadmin group may gain root privileges
%sysadmin     ALL=(ALL) <%= "NOPASSWD:" if @passwordless %>ALL

<% @sudoers_groups.each do |group| -%>
# Members of the group '<%= group %>' may gain root privileges
%<%= group %> ALL=(ALL) <%= "NOPASSWD:" if @passwordless %>ALL
<% end -%>
\end{lstlisting}

And then set the default attributes in \inline{attributes/default.rb}:

\begin{lstlisting}[label=lst:cookbook-templates3]
default["authorization"]["sudo"]["groups"] = [ "sysadmin","wheel","admin" ]
default["authorization"]["sudo"]["users"]  = [ "jerry","greg"]
\end{lstlisting}

When a template is rendered, Ruby expressions and statements are evaluated by the chef-client. The variables listed in the resourceâ€™s variables parameter and the node object are evaluated. The chef-client then passes these variables to the template, where they will be accessible as instance variables within the template; the node object can be accessed just as if it were part of a recipe, using the same syntax.

For example, a simple template resource like this:

\begin{lstlisting}[label=lst:cookbook-templates4]
node[:fqdn] = "latte"
template "/tmp/foo" do
  source "foo.erb"
  variables({
    :x_men => "are keen"
  })
end
\end{lstlisting}

And a simple Embedded Ruby (ERB) template like this:

\begin{lstlisting}[label=lst:cookbook-templates5]
The node <%= node[:fqdn] %> thinks the x-men <%= @x_men %>
\end{lstlisting}

Would render something like:

\begin{lstlisting}[label=lst:cookbook-templates6]
The node latte thinks the x-men are keen
\end{lstlisting}

Even though this is a very simple example, the full capabilities of Ruby can be used to tackle even the most complex and demanding template requirements.

\subsection{File Specificity}

A cookbook will frequently be designed to work across many platforms and will often be required to distribute a specific file to a specific platform. A cookbook can be designed to support distributing files across platforms, but ensuring that the right file ends up on each system.

TODO