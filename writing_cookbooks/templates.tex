\section{Templates}

As you can see in previous chapter we used resource \inline{template} for generate nginx config in default recipe. A cookbook template is a file written in a markup language that allows the contents of a file to be dynamically generated based on variables or complex logic. Templates can contain Ruby expressions and statements. Templates are a great way to manage configuration files across an organization. A template requires a template resource being added to a recipe and then a corresponding Embedded Ruby (ERB) template being added to a cookbook.

To use a template, two things must happen:

\begin{itemize}
  \item A template resource must be added to a recipe
  \item An Embedded Ruby (ERB) template must be added to a cookbook
\end{itemize}

For example, the following template file and template resource settings can be used to manage a configuration file named \inline{/etc/sudoers}. Within a cookbook that uses sudo, the following resource could be added to \inline{recipes/default.rb}:

\begin{lstlisting}[label=lst:cookbook-templates1]
template "/etc/sudoers" do
  source "sudoers.erb"
  mode 0440
  owner "root"
  group "root"
  variables({
     :sudoers_groups => node[:authorization][:sudo][:groups],
     :sudoers_users => node[:authorization][:sudo][:users]
  })
end
\end{lstlisting}

And then create a template called \inline{sudoers.erb} and save it to \inline{templates/default/sudoers.erb}:

\begin{lstlisting}[label=lst:cookbook-templates2]
#
# /etc/sudoers
#
# Generated by Chef for <%= node[:fqdn] %>
#

Defaults        !lecture,tty_tickets,!fqdn

# User privilege specification
root          ALL=(ALL) ALL

<% @sudoers_users.each do |user| -%>
<%= user %>   ALL=(ALL) <%= "NOPASSWD:" if @passwordless %>ALL
<% end -%>

# Members of the sysadmin group may gain root privileges
%sysadmin     ALL=(ALL) <%= "NOPASSWD:" if @passwordless %>ALL

<% @sudoers_groups.each do |group| -%>
# Members of the group '<%= group %>' may gain root privileges
%<%= group %> ALL=(ALL) <%= "NOPASSWD:" if @passwordless %>ALL
<% end -%>
\end{lstlisting}

And then set the default attributes in \inline{attributes/default.rb}:

\begin{lstlisting}[label=lst:cookbook-templates3]
default["authorization"]["sudo"]["groups"] = [ "sysadmin","wheel","admin" ]
default["authorization"]["sudo"]["users"]  = [ "jerry","greg"]
\end{lstlisting}

When a template is rendered, Ruby expressions and statements are evaluated by the chef-client. The variables listed in the resourceâ€™s variables parameter and the node object are evaluated. The chef-client then passes these variables to the template, where they will be accessible as instance variables within the template; the node object can be accessed just as if it were part of a recipe, using the same syntax.

For example, a simple template resource like this:

\begin{lstlisting}[label=lst:cookbook-templates4]
node[:fqdn] = "latte"
template "/tmp/foo" do
  source "foo.erb"
  variables({
    :x_men => "are keen"
  })
end
\end{lstlisting}

And a simple Embedded Ruby (ERB) template like this:

\begin{lstlisting}[label=lst:cookbook-templates5]
The node <%= node[:fqdn] %> thinks the x-men <%= @x_men %>
\end{lstlisting}

Would render something like:

\begin{lstlisting}[label=lst:cookbook-templates6]
The node latte thinks the x-men are keen
\end{lstlisting}

Even though this is a very simple example, the full capabilities of Ruby can be used to tackle even the most complex and demanding template requirements.

\subsection{File Specificity}

A cookbook will frequently be designed to work across many platforms and will often be required to distribute a specific file to a specific platform. A cookbook can be designed to support distributing files across platforms, but ensuring that the right file ends up on each system.

The pattern for file specificity is as follows:

\begin{enumerate}
  \item \inline{host-node[:fqdn]}
  \item \inline{node[:platform]-node[:platform_version]}
  \item \inline{node[:platform]-version_components}: The version string is split on decimals and searched from greatest specificity to least; for example, if the location from the last rule was centos-5.7.1, then centos-5.7 and centos-5 would also be searched.
  \item \inline{node[:platform]}
  \item \inline{default}
\end{enumerate}

The naming of folders within cookbook directories must literally match the host notation used for template specificity matching. For example, if a host is named <<foo.example.com>>, then the folder must be named <<host-foo.example.com>>.

A cookbook may have a \inline{/templates} directory structure like this:

\begin{lstlisting}[language=Bash,label=lst:cookbook-templates7]
templates/
  windows-6.2
  windows-6.1
  windows-6.0
  windows
  default
\end{lstlisting}

and a resource that looks something like the following:

\begin{lstlisting}[label=lst:cookbook-templates8]
template "C:\path\to\file\text_file.txt" do
  source "text_file.txt"
  mode 0755
  owner "root"
  group "root"
end
\end{lstlisting}

This resource would be matched in the same order as the /templates directory structure. For a node named <<host-node-desktop>> that is running Windows 7, the second item would be the matching item and the location:

\begin{lstlisting}[language=Bash,label=lst:cookbook-templates8]
/templates
  windows-6.2/text_file.txt
  windows-6.1/text_file.txt
  windows-6.0/text_file.txt
  windows/text_file.txt
  default/text_file.txt
\end{lstlisting}

\subsection{Partial Templates}

A template can be built in a way that allows it to contain references to one (or more) smaller template files. (These smaller template files are also referred to as partials.) A partial can be referenced from a template file in one of the following ways:

\begin{itemize}
  \item By using the Ruby render method in the template file
  \item By using the template resource and the variables parameter
\end{itemize}

Use the render method in a template to reference a partial template file with the following syntax:

\begin{lstlisting}[language=Bash,label=lst:cookbook-templates9]
<%= render "partial_name.txt.erb", :option => {} %>
\end{lstlisting}

where \inline{partial_name.txt.erb} is the name of the partial template file and \inline{:option} is one (or more) of the following options:

\begin{itemize}
  \item \inline{:cookbook} - by default, a partial template file is assumed to be located in the cookbook that contains the top-level template. Use this option to specify the path to a different cookbook
  \item \inline{:local} - indicates that the name of the partial template file should be interpreted as a path to a file in the local file system or looked up in a cookbook using the normal rules for template files. Set to true to interpret as a path to a file in the local file system and to false to use the normal rules for template files
  \item \inline{:source} - by default, a partial template file is identified by its file name. Use this option to specify a different name or a local path to use (instead of the name of the partial template file)
  \item \inline{:variables} - a hash of \inline{variable_name => value} that will be made available to the partial template file. When this option is used, any variables that are defined in the top-level template that are required by the partial template file must have them defined explicitly using this option
\end{itemize}

For example:

\begin{lstlisting}[language=Bash,label=lst:cookbook-templates10]
<%= render "simple.txt.erb", :variables => {:user => @user }, :local => true %>
\end{lstlisting}

